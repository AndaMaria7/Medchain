import{createHash as t}from"crypto";import{ethers as e}from"ethers";import{dirname as a,resolve as d}from"path";import{fromRdf as s}from"rdf-literal";import{Readable as i}from"stream";import{fileURLToPath as n}from"url";import{existsSync as r}from"fs";let l,o,c;const u=async()=>{if(!c){const t=await import("@rdfjs/formats-common");c=t.default}if(!l){const t=await import("@zazuko/env-node");l=t.default,l.formats.import(c)}if(!o){const t=await import("rdf-validate-shacl");o=t.default}return{formats:c,rdf:l,SHACLValidator:o}},D=["4.1.0","4.3.0","4.5.0","4.7.0","5.0.0","deprecated"];class f{constructor(t){this.ddoData=void 0,this.ddoData=t}getDDOData(){return this.ddoData}deleteIndexedMetadataIfExists(t){const e=structuredClone(t);return"indexedMetadata"in e?(delete e.indexedMetadata,e):t}getDid(){return this.getDDOData().id||null}getSchema(t="5.0.0"){if(!D.includes(t))throw new Error(`Unsupported schema version: ${t}`);const e=n(import.meta.url),s=a(e),i=d(s,`../schemas/${t}.ttl`);return r(i)?i:d(s,`../../schemas/${t}.ttl`)}static getDDOClass(t){const{version:e,id:a}=t;if(e.startsWith("4")&&a.startsWith("did:op"))return new h(t);if(e.startsWith("5")&&a.startsWith("did:ope"))return new p(t);if("deprecated"===e)return new g(t);throw new Error(`Unsupported DDO version: ${e}`)}}class h extends f{constructor(t){super(t)}getDDOFields(){const t=this.getDDOData();return{id:t.id||null,version:t.version||null,metadata:t.metadata||null,services:t.services||null,chainId:t.chainId||null,credentials:t.credentials||null,nftAddress:t.nftAddress||null}}getAssetFields(){return{indexedMetadata:this.getDDOData().indexedMetadata,datatokens:this.getDDOData().datatokens}}makeDid(a,d){return"did:op:"+t("sha256").update(e.utils.getAddress(a)+d).digest("hex")}updateFields(t){var e,a,d,s;return t.id&&(this.getDDOData().id=t.id),t.nftAddress&&(this.getDDOData().nftAddress=t.nftAddress),t.chainId&&(this.getDDOData().chainId=t.chainId),t.datatokens&&(this.getDDOData().datatokens=t.datatokens),null!=(e=t.indexedMetadata)&&e.nft&&(this.getDDOData().indexedMetadata.nft=t.indexedMetadata.nft),null!=(a=t.indexedMetadata)&&a.event&&(this.getDDOData().indexedMetadata.event=t.indexedMetadata.event),null!=(d=t.indexedMetadata)&&d.purgatory&&(this.getDDOData().indexedMetadata.purgatory=t.indexedMetadata.purgatory),t.services&&(this.getDDOData().services=t.services),null!=(s=t.indexedMetadata)&&s.stats&&(this.getDDOData().indexedMetadata.stats=t.indexedMetadata.stats),this.getDDOData()}async validate(){const{rdf:t,formats:a,SHACLValidator:d}=await u(),n=this.deleteIndexedMetadataIfExists(this.getDDOData()),r=JSON.parse(JSON.stringify(n)),{chainId:l,nftAddress:o}=r,c={};r["@type"]="DDO",r["@context"]={"@vocab":"http://schema.org/"},l||("chainId"in c||(c.chainId=[]),c.chainId.push("chainId is missing or invalid."));try{e.utils.getAddress(o)}catch(t){"nftAddress"in c||(c.nftAddress=[]),c.nftAddress.push("nftAddress is missing or invalid.")}this.makeDid(o,l.toString(10))!==r.id&&("id"in c||(c.id=[]),c.id.push("did is not valid for chain Id and nft address"));const D=this.getSchema(r.version),f=await t.dataset().import(t.fromFile(D)),h=i.from(JSON.stringify(r)),p=a.parsers.import("application/ld+json",h);if(!p)return c.output=["Output is null or invalid"],[!1,c];const g=await t.dataset().import(p),v=new d(f,{factory:t}),m=await v.validate(g);if(m.conforms)return[!0,{}];for(const t of m.results){var O;const e=null==(O=t.path)?void 0:O.value.replace("http://schema.org/","");e&&(e in c||(c[e]=[]),c[e].push(s(t.message[0])))}return c.fullReport=await m.dataset.serialize({format:"application/ld+json"}),[!1,c]}}class p extends f{constructor(t){super(t)}makeDid(a,d){return"did:ope:"+t("sha256").update(e.utils.getAddress(a)+d).digest("hex")}getDDOFields(){var t,e,a,d,s;const i=this.getDDOData();return{id:(null==i?void 0:i.id)||null,version:(null==i?void 0:i.version)||null,metadata:(null==(t=i.credentialSubject)?void 0:t.metadata)||null,services:(null==(e=i.credentialSubject)?void 0:e.services)||null,chainId:(null==(a=i.credentialSubject)?void 0:a.chainId)||null,credentials:(null==(d=i.credentialSubject)?void 0:d.credentials)||null,nftAddress:(null==(s=i.credentialSubject)?void 0:s.nftAddress)||null}}getAssetFields(){var t,e;return{indexedMetadata:null==(t=this.getDDOData())?void 0:t.indexedMetadata,datatokens:null==(e=this.getDDOData().credentialSubject)?void 0:e.datatokens}}getProof(){return this.getDDOData().proof}getIssuer(){return this.getDDOData().issuer}updateFields(t){var e,a,d,s;const i=this.getDDOData().credentialSubject||{};return t.id&&(this.getDDOData().id=t.id),t.nftAddress&&(i.nftAddress=t.nftAddress),t.chainId&&(i.chainId=t.chainId),t.datatokens&&(i.datatokens=t.datatokens),null!=(e=t.indexedMetadata)&&e.nft&&(this.getDDOData().indexedMetadata.nft=t.indexedMetadata.nft),null!=(a=t.indexedMetadata)&&a.event&&(this.getDDOData().indexedMetadata.event=t.indexedMetadata.event),null!=(d=t.indexedMetadata)&&d.purgatory&&(this.getDDOData().indexedMetadata.purgatory=t.indexedMetadata.purgatory),t.services&&(i.services=t.services),null!=(s=t.indexedMetadata)&&s.stats&&(this.getDDOData().indexedMetadata.stats=t.indexedMetadata.stats),t.issuer&&(this.getDDOData().issuer=t.issuer),t.proof&&(this.getDDOData().proof=t.proof),this.getDDOData().credentialSubject=i,this.getDDOData()}async validate(){const{rdf:t,formats:a,SHACLValidator:d}=await u(),s=this.deleteIndexedMetadataIfExists(this.getDDOData()),n=JSON.parse(JSON.stringify(s)),{chainId:r,nftAddress:l}=n.credentialSubject,o={};n["@type"]="VerifiableCredential",n["@context"]={"@vocab":"https://www.w3.org/ns/credentials/v2/"},n.credentialSubject.chainId||(o.chainId=["chainId is missing or invalid."]);try{e.utils.getAddress(l)}catch(t){o.nftAddress=["nftAddress is missing or invalid."]}this.makeDid(l,r.toString(10))!==n.id&&(o.id=["did is not valid for chainId and nft address"]),n.credentialSubject.metadata||(o.metadata=["metadata is missing or invalid."]),n.credentialSubject.services||(o.services=["services are missing or invalid."]);const c=this.getSchema(n.version),D=await t.dataset().import(t.fromFile(c)),f=i.from(JSON.stringify(n)),h=a.parsers.import("application/ld+json",f);if(!h)return o.output=["Output is null or invalid"],[!1,o];const p=await t.dataset().import(h),g=new d(D,{factory:t}),v=await g.validate(p);if(v.conforms)return[!0,{}];for(const t of v.results){var m;const e=null==t||null==(m=t.path)?void 0:m.value.replace("https://www.w3.org/ns/credentials/v2/","");e&&(e in o||(o[e]=[]),o[e].push(t.message[0].value))}return o.fullReport=await v.dataset.serialize({format:"application/ld+json"}),[!1,o]}}class g extends f{constructor(t){super(t)}makeDid(a,d){return"did:op:"+t("sha256").update(e.utils.getAddress(a)+d).digest("hex")}getDDOFields(){const t=this.getDDOData();return{id:(null==t?void 0:t.id)||null,version:"deprecated",chainId:(null==t?void 0:t.chainId)||null,nftAddress:(null==t?void 0:t.nftAddress)||null,metadata:null,services:null,credentials:null}}getAssetFields(){const{indexedMetadata:t}=this.getDDOData();return t.event=null,t.purgatory=null,t.stats=null,t.nft={state:this.getDDOData().indexedMetadata.nft.state,address:null,name:null,symbol:null,owner:null,created:null,tokenURI:null},{indexedMetadata:t,datatokens:null}}updateFields(t){var e;const a=this.getDDOData()||{};return t.id&&(a.id=t.id),t.nftAddress&&(a.nftAddress=t.nftAddress),t.chainId&&(a.chainId=t.chainId),null!=(e=t.indexedMetadata)&&null!=(e=e.nft)&&e.state&&(a.indexedMetadata.nft.state=t.indexedMetadata.nft.state),a}async validate(){const{rdf:t,formats:a,SHACLValidator:d}=await u(),n=this.deleteIndexedMetadataIfExists(this.getDDOData()),r=JSON.parse(JSON.stringify(n)),{chainId:l,nftAddress:o}=r,c={};r["@type"]="DDO",r["@context"]={"@vocab":"http://schema.org/"},l||("chainId"in c||(c.chainId=[]),c.chainId.push("chainId is missing or invalid."));try{e.utils.getAddress(o)}catch(t){"nftAddress"in c||(c.nftAddress=[]),c.nftAddress.push("nftAddress is missing or invalid.")}this.makeDid(o,l.toString(10))!==r.id&&("id"in c||(c.id=[]),c.id.push("did is not valid for chain Id and nft address"));const D=this.getSchema(r.version),f=await t.dataset().import(t.fromFile(D)),h=i.from(JSON.stringify(r)),p=a.parsers.import("application/ld+json",h);if(!p)return c.output=["Output is null or invalid"],[!1,c];const g=await t.dataset().import(p),v=new d(f,{factory:t}),m=await v.validate(g);if(m.conforms)return[!0,{}];for(const t of m.results){var O;const e=null==(O=t.path)?void 0:O.value.replace("http://schema.org/","");e&&(e in c||(c[e]=[]),c[e].push(s(t.message[0])))}return c.fullReport=await m.dataset.serialize({format:"application/ld+json"}),[!1,c]}}async function v(t){try{const e=f.getDDOClass(t);return await e.validate()}catch(t){return[!1,{general:[`Validation failed: ${t}`]}]}}var m;!function(t){t.ADDRESS="address",t.ACCESS_LIST="accessList",t.POLICY_SERVER_SPECIFIC="PS-specific Type"}(m||(m={}));const O=[m.ADDRESS,m.ACCESS_LIST];var x;!function(t){t[t.Active=0]="Active",t[t.EndOfLife=1]="EndOfLife",t[t.Deprecated=2]="Deprecated",t[t.RevokedByPublisher=3]="RevokedByPublisher",t[t.OrderingIsTemporaryDisabled=4]="OrderingIsTemporaryDisabled",t[t.AssetUnlisted=5]="AssetUnlisted"}(x||(x={}));export{m as CREDENTIALS_TYPES,f as DDOManager,g as DeprecatedDDO,O as KNOWN_CREDENTIALS_TYPES,x as State,h as V4DDO,p as V5DDO,v as validateDDO};
//# sourceMappingURL=ddo.module.modern.js.map
