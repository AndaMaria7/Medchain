{"version":3,"file":"ddo.module.js","sources":["../src/utils/importUtils.ts","../src/@types/DDO4/Credentials.ts","../src/services/ddoManager.ts","../src/@types/DDO5/State.ts"],"sourcesContent":["let rdf;\nlet SHACLValidator;\nlet formats;\n\nexport const getRdfjsLibraries = async () => {\n  if (!formats) {\n    const formatsModule = await import('@rdfjs/formats-common');\n    formats = formatsModule.default;\n  }\n\n  if (!rdf) {\n    const envNode = await import('@zazuko/env-node');\n    rdf = envNode.default;\n    rdf.formats.import(formats);\n  }\n\n  if (!SHACLValidator) {\n    const shaclModule = await import('rdf-validate-shacl');\n    SHACLValidator = shaclModule.default;\n  }\n\n  return { formats, rdf, SHACLValidator };\n};\n","/* eslint-disable no-unused-vars */\nexport enum CREDENTIALS_TYPES {\n  ADDRESS = 'address',\n  ACCESS_LIST = 'accessList',\n  POLICY_SERVER_SPECIFIC = 'PS-specific Type' // externally handled type\n}\n\nexport const KNOWN_CREDENTIALS_TYPES = [\n  CREDENTIALS_TYPES.ADDRESS,\n  CREDENTIALS_TYPES.ACCESS_LIST\n];\n\nexport interface Credential {\n  type?: CREDENTIALS_TYPES;\n  values?: string[];\n}\n\nexport type MATCH_RULES = 'any' | 'all';\n\nexport interface Credentials {\n  match_allow?: MATCH_RULES; // any =>  it's enough to have one rule matched, all => all allow rules should match, default: 'all'\n  match_deny?: MATCH_RULES; // same pattern as above, default is 'any'\n  allow?: Credential[];\n  deny?: Credential[];\n}\n","import { createHash } from 'crypto';\nimport { ethers } from 'ethers';\nimport { dirname, resolve } from 'path';\nimport { fromRdf } from 'rdf-literal';\n// @ts-ignore\nimport { Readable } from 'stream';\nimport { fileURLToPath } from 'url';\nimport { AssetFields } from '../@types/AssetTypes.js';\nimport { Service as ServiceV4 } from '../@types/DDO4/Service.js';\nimport { Service as ServiceV5 } from '../@types/DDO5/Service.js';\nimport {\n  CredentialSubject,\n  DDOFields,\n  Proof,\n  UpdateFields,\n  VersionedDDO\n} from '../@types/index.js';\nimport { existsSync } from 'fs';\nimport { getRdfjsLibraries } from '../utils/importUtils.js';\n\nconst CURRENT_VERSION = '5.0.0';\nconst ALLOWED_VERSIONS = [\n  '4.1.0',\n  '4.3.0',\n  '4.5.0',\n  '4.7.0',\n  '5.0.0',\n  'deprecated'\n];\n\nexport abstract class DDOManager {\n  private ddoData: Record<string, any>;\n\n  /**\n   * Constructor for DDOManager.\n   * @param ddoData - The data object representing the DDO.\n   */\n  public constructor(ddoData: Record<string, any>) {\n    this.ddoData = ddoData;\n  }\n\n  /**\n   * Abstract method to generate a DID (Decentralized Identifier).\n   * @param nftAddress - The NFT address.\n   * @param chainId - The chain ID.\n   * @returns A string representing the DID.\n   */\n  abstract makeDid(nftAddress: string, chainId: string): string;\n\n  /**\n   * Abstract method to retrieve DDO fields.\n   * `DDOFields` or `CredentialSubject` contains the following structure:\n   * - **id**: The Decentralized Identifier (DID) of the asset.\n   * - **metadata**: The metadata describing the asset.\n   * - **services**: An array of services associated with the asset.\n   * - **credentials**: An array of verifiable credentials.\n   * - **chainId**: The blockchain chain ID where the asset is registered.\n   * - **nftAddress**: The address of the NFT representing the asset.\n   * - **event** (optional): The last event related to the asset.\n   *\n   * @returns The DDO fields as `DDOFields` or `CredentialSubject`.\n   */\n  abstract getDDOFields(): DDOFields | CredentialSubject;\n\n  /**\n   * Abstract method to retrieve asset fields.\n   * `AssetFields` contains the following structure:\n   * - **datatokens** (optional): The datatokens associated with the asset.\n   * - **event** (optional): The last event related to the asset.\n   * - **nft** (optional): Information about the NFT representing the asset.\n   * - **purgatory** (optional): Purgatory status of the asset, if applicable.\n   * - **stats** (optional): Statistical information about the asset (e.g., usage, views).\n   *\n   * @returns The asset fields as `AssetFields`.\n   */\n  abstract getAssetFields(): AssetFields;\n\n  /**\n   * Retrieves the DDO data.\n   * @returns The DDO data as a record.\n   */\n  public getDDOData(): Record<string, any> {\n    return this.ddoData;\n  }\n\n  public deleteIndexedMetadataIfExists(\n    ddo: Record<string, any>\n  ): Record<string, any> {\n    const ddoCopy: Record<string, any> = structuredClone(ddo);\n    if ('indexedMetadata' in ddoCopy) {\n      delete ddoCopy.indexedMetadata;\n      return ddoCopy;\n    }\n    return ddo;\n  }\n\n  /**\n   * Abstract method to update multiple fields.\n   * @param fields - Partial object containing fields to update.\n   * @returns The updated DDO data.\n   */\n  abstract updateFields(fields: UpdateFields): Record<string, any>;\n\n  /**\n   * Method to retrieve the DID.\n   * @returns The DID of ddo.\n   */\n  public getDid(): string {\n    return this.getDDOData().id || null;\n  }\n\n  /**\n   * Resolves the schema file path for a given version.\n   * @param version - The schema version (default: CURRENT_VERSION).\n   * @returns The resolved schema file path.\n   * @throws An error if the version is not supported.\n   */\n  public getSchema(version: string = CURRENT_VERSION): string {\n    if (!ALLOWED_VERSIONS.includes(version)) {\n      throw new Error(`Unsupported schema version: ${version}`);\n    }\n\n    const currentModulePath = fileURLToPath(import.meta.url);\n    const currentDirectory = dirname(currentModulePath);\n\n    const schemaPath = resolve(currentDirectory, `../schemas/${version}.ttl`);\n    if (existsSync(schemaPath)) {\n      return schemaPath;\n    }\n\n    return resolve(currentDirectory, `../../schemas/${version}.ttl`);\n  }\n\n  /**\n   * Factory method to get a DDO class instance based on version.\n   * @param ddoData - The DDO data object.\n   * @returns An instance of `V4DDO` or `V5DDO` or `DeprecatedDDO`.\n   * @throws An error if the version is not supported.\n   */\n  public static getDDOClass(ddoData: Record<string, any>): VersionedDDO {\n    const { version, id } = ddoData;\n    if (version.startsWith('4') && id.startsWith('did:op')) {\n      return new V4DDO(ddoData);\n    } else if (version.startsWith('5') && id.startsWith('did:ope')) {\n      return new V5DDO(ddoData);\n    } else if (version === 'deprecated') {\n      return new DeprecatedDDO(ddoData);\n    }\n    throw new Error(`Unsupported DDO version: ${version}`);\n  }\n}\n\n// V4 DDO implementation\nexport class V4DDO extends DDOManager {\n  public constructor(ddoData: Record<string, any>) {\n    super(ddoData);\n  }\n\n  getDDOFields(): DDOFields {\n    const data = this.getDDOData();\n    return {\n      id: data.id || null,\n      version: data.version || null,\n      metadata: data.metadata || null,\n      services: data.services || null,\n      chainId: data.chainId || null,\n      credentials: data.credentials || null,\n      nftAddress: data.nftAddress || null\n    };\n  }\n\n  getAssetFields(): AssetFields {\n    return {\n      indexedMetadata: this.getDDOData().indexedMetadata,\n      datatokens: this.getDDOData().datatokens\n    };\n  }\n\n  makeDid(nftAddress: string, chainId: string): string {\n    return (\n      'did:op:' +\n      createHash('sha256')\n        .update(ethers.utils.getAddress(nftAddress) + chainId)\n        .digest('hex')\n    );\n  }\n\n  updateFields(fields: UpdateFields): Record<string, any> {\n    if (fields.id) this.getDDOData().id = fields.id;\n    if (fields.nftAddress) this.getDDOData().nftAddress = fields.nftAddress;\n    if (fields.chainId) this.getDDOData().chainId = fields.chainId;\n    if (fields.datatokens) this.getDDOData().datatokens = fields.datatokens;\n    if (fields.indexedMetadata?.nft)\n      this.getDDOData().indexedMetadata.nft = fields.indexedMetadata.nft;\n    if (fields.indexedMetadata?.event)\n      this.getDDOData().indexedMetadata.event = fields.indexedMetadata.event;\n    if (fields.indexedMetadata?.purgatory)\n      this.getDDOData().indexedMetadata.purgatory =\n        fields.indexedMetadata.purgatory;\n    if (fields.services)\n      this.getDDOData().services = fields.services as ServiceV4[];\n    if (fields.indexedMetadata?.stats)\n      this.getDDOData().indexedMetadata.stats = fields.indexedMetadata.stats;\n    return this.getDDOData();\n  }\n\n  async validate(): Promise<[boolean, Record<string, string[]>]> {\n    const { rdf, formats, SHACLValidator } = await getRdfjsLibraries();\n    const updatedDdo = this.deleteIndexedMetadataIfExists(this.getDDOData());\n    const ddoCopy = JSON.parse(JSON.stringify(updatedDdo));\n    const { chainId, nftAddress } = ddoCopy;\n    const extraErrors: Record<string, string[]> = {};\n    ddoCopy['@type'] = 'DDO';\n    ddoCopy['@context'] = {\n      '@vocab': 'http://schema.org/'\n    };\n    if (!chainId) {\n      if (!('chainId' in extraErrors)) extraErrors.chainId = [];\n      extraErrors.chainId.push('chainId is missing or invalid.');\n    }\n\n    try {\n      ethers.utils.getAddress(nftAddress);\n    } catch (err) {\n      if (!('nftAddress' in extraErrors)) extraErrors.nftAddress = [];\n      extraErrors.nftAddress.push('nftAddress is missing or invalid.');\n    }\n\n    if (!(this.makeDid(nftAddress, chainId.toString(10)) === ddoCopy.id)) {\n      if (!('id' in extraErrors)) extraErrors.id = [];\n      extraErrors.id.push('did is not valid for chain Id and nft address');\n    }\n    const schemaFilePath = this.getSchema(ddoCopy.version);\n    const shapes = await rdf.dataset().import(rdf.fromFile(schemaFilePath));\n    const dataStream = Readable.from(JSON.stringify(ddoCopy));\n    const output = formats.parsers.import('application/ld+json', dataStream);\n    if (!output) {\n      extraErrors.output = ['Output is null or invalid'];\n      return [false, extraErrors];\n    }\n    const data = await rdf.dataset().import(output);\n    const validator = new SHACLValidator(shapes, { factory: rdf });\n    const report = await validator.validate(data);\n    if (report.conforms) {\n      return [true, {}];\n    }\n    for (const result of report.results) {\n      const key = result.path?.value.replace('http://schema.org/', '');\n      if (key) {\n        if (!(key in extraErrors)) extraErrors[key] = [];\n        extraErrors[key].push(fromRdf(result.message[0]));\n      }\n    }\n    extraErrors.fullReport = await report.dataset.serialize({\n      format: 'application/ld+json'\n    });\n    return [false, extraErrors];\n  }\n}\n\n// V5 DDO implementation\nexport class V5DDO extends DDOManager {\n  public constructor(ddoData: Record<string, any>) {\n    super(ddoData);\n  }\n\n  makeDid(nftAddress: string, chainId: string): string {\n    return (\n      'did:ope:' +\n      createHash('sha256')\n        .update(ethers.utils.getAddress(nftAddress) + chainId)\n        .digest('hex')\n    );\n  }\n\n  getDDOFields(): CredentialSubject {\n    const data = this.getDDOData();\n    return {\n      id: data?.id || null,\n      version: data?.version || null,\n      metadata: data.credentialSubject?.metadata || null,\n      services: data.credentialSubject?.services || null,\n      chainId: data.credentialSubject?.chainId || null,\n      credentials: data.credentialSubject?.credentials || null,\n      nftAddress: data.credentialSubject?.nftAddress || null\n    };\n  }\n\n  getAssetFields(): AssetFields {\n    return {\n      indexedMetadata: this.getDDOData()?.indexedMetadata,\n      datatokens: this.getDDOData().credentialSubject?.datatokens\n    };\n  }\n\n  getProof(): Proof {\n    return this.getDDOData().proof;\n  }\n\n  getIssuer(): string {\n    return this.getDDOData().issuer;\n  }\n\n  updateFields(fields: UpdateFields): Record<string, any> {\n    const credentialSubject = this.getDDOData().credentialSubject || {};\n    if (fields.id) this.getDDOData().id = fields.id;\n    if (fields.nftAddress) credentialSubject.nftAddress = fields.nftAddress;\n    if (fields.chainId) credentialSubject.chainId = fields.chainId;\n    if (fields.datatokens) credentialSubject.datatokens = fields.datatokens;\n    if (fields.indexedMetadata?.nft)\n      this.getDDOData().indexedMetadata.nft = fields.indexedMetadata.nft;\n    if (fields.indexedMetadata?.event)\n      this.getDDOData().indexedMetadata.event = fields.indexedMetadata.event;\n    if (fields.indexedMetadata?.purgatory)\n      this.getDDOData().indexedMetadata.purgatory =\n        fields.indexedMetadata.purgatory;\n    if (fields.services)\n      credentialSubject.services = fields.services as ServiceV5[];\n    if (fields.indexedMetadata?.stats)\n      this.getDDOData().indexedMetadata.stats = fields.indexedMetadata.stats;\n    if (fields.issuer) this.getDDOData().issuer = fields.issuer;\n    if (fields.proof) this.getDDOData().proof = fields.proof;\n    this.getDDOData().credentialSubject = credentialSubject;\n    return this.getDDOData();\n  }\n\n  async validate(): Promise<[boolean, Record<string, string[]>]> {\n    const { rdf, formats, SHACLValidator } = await getRdfjsLibraries();\n    const updatedDdo = this.deleteIndexedMetadataIfExists(this.getDDOData());\n    const ddoCopy = JSON.parse(JSON.stringify(updatedDdo));\n    const { chainId, nftAddress } = ddoCopy.credentialSubject;\n    const extraErrors: Record<string, string[]> = {};\n    ddoCopy['@type'] = 'VerifiableCredential';\n    ddoCopy['@context'] = {\n      '@vocab': 'https://www.w3.org/ns/credentials/v2/'\n    };\n    if (!ddoCopy.credentialSubject.chainId) {\n      extraErrors.chainId = ['chainId is missing or invalid.'];\n    }\n\n    try {\n      ethers.utils.getAddress(nftAddress);\n    } catch (err) {\n      extraErrors.nftAddress = ['nftAddress is missing or invalid.'];\n    }\n\n    if (!(this.makeDid(nftAddress, chainId.toString(10)) === ddoCopy.id)) {\n      extraErrors.id = ['did is not valid for chainId and nft address'];\n    }\n\n    if (!ddoCopy.credentialSubject.metadata) {\n      extraErrors.metadata = ['metadata is missing or invalid.'];\n    }\n\n    if (!ddoCopy.credentialSubject.services) {\n      extraErrors.services = ['services are missing or invalid.'];\n    }\n\n    const schemaFilePath = this.getSchema(ddoCopy.version);\n\n    const shapes = await rdf.dataset().import(rdf.fromFile(schemaFilePath));\n    const dataStream = Readable.from(JSON.stringify(ddoCopy));\n    const output = formats.parsers.import('application/ld+json', dataStream);\n    if (!output) {\n      extraErrors.output = ['Output is null or invalid'];\n      return [false, extraErrors];\n    }\n    const data = await rdf.dataset().import(output);\n    const validator = new SHACLValidator(shapes, { factory: rdf });\n    const report = await validator.validate(data);\n\n    if (report.conforms) {\n      return [true, {}];\n    }\n\n    for (const result of report.results) {\n      const key = result?.path?.value.replace(\n        'https://www.w3.org/ns/credentials/v2/',\n        ''\n      );\n      if (key) {\n        if (!(key in extraErrors)) extraErrors[key] = [];\n        extraErrors[key].push(result.message[0].value);\n      }\n    }\n\n    extraErrors.fullReport = await report.dataset.serialize({\n      format: 'application/ld+json'\n    });\n    return [false, extraErrors];\n  }\n}\n\n// Deprecated DDO implementation\nexport class DeprecatedDDO extends DDOManager {\n  public constructor(ddoData: Record<string, any>) {\n    super(ddoData);\n  }\n\n  makeDid(nftAddress: string, chainId: string): string {\n    return (\n      'did:op:' +\n      createHash('sha256')\n        .update(ethers.utils.getAddress(nftAddress) + chainId)\n        .digest('hex')\n    );\n  }\n\n  getDDOFields(): DDOFields {\n    const data = this.getDDOData();\n    return {\n      id: data?.id || null,\n      version: 'deprecated',\n      chainId: data?.chainId || null,\n      nftAddress: data?.nftAddress || null,\n      metadata: null,\n      services: null,\n      credentials: null\n    };\n  }\n\n  getAssetFields(): AssetFields {\n    const { indexedMetadata } = this.getDDOData();\n    indexedMetadata.event = null;\n    indexedMetadata.purgatory = null;\n    indexedMetadata.stats = null;\n    indexedMetadata.nft = {\n      state: this.getDDOData().indexedMetadata.nft.state,\n      address: null,\n      name: null,\n      symbol: null,\n      owner: null,\n      created: null,\n      tokenURI: null\n    };\n\n    return {\n      indexedMetadata,\n      datatokens: null\n    };\n  }\n\n  updateFields(fields: UpdateFields): Record<string, any> {\n    const ddo = this.getDDOData() || {};\n    if (fields.id) ddo.id = fields.id;\n    if (fields.nftAddress) ddo.nftAddress = fields.nftAddress;\n    if (fields.chainId) ddo.chainId = fields.chainId;\n    if (fields.indexedMetadata?.nft?.state)\n      ddo.indexedMetadata.nft.state = fields.indexedMetadata.nft.state;\n    return ddo;\n  }\n\n  async validate(): Promise<[boolean, Record<string, string[]>]> {\n    const { rdf, formats, SHACLValidator } = await getRdfjsLibraries();\n    const updatedDdo = this.deleteIndexedMetadataIfExists(this.getDDOData());\n    const ddoCopy = JSON.parse(JSON.stringify(updatedDdo));\n    const { chainId, nftAddress } = ddoCopy;\n    const extraErrors: Record<string, string[]> = {};\n    ddoCopy['@type'] = 'DDO';\n    ddoCopy['@context'] = {\n      '@vocab': 'http://schema.org/'\n    };\n    if (!chainId) {\n      if (!('chainId' in extraErrors)) extraErrors.chainId = [];\n      extraErrors.chainId.push('chainId is missing or invalid.');\n    }\n\n    try {\n      ethers.utils.getAddress(nftAddress);\n    } catch (err) {\n      if (!('nftAddress' in extraErrors)) extraErrors.nftAddress = [];\n      extraErrors.nftAddress.push('nftAddress is missing or invalid.');\n    }\n\n    if (!(this.makeDid(nftAddress, chainId.toString(10)) === ddoCopy.id)) {\n      if (!('id' in extraErrors)) extraErrors.id = [];\n      extraErrors.id.push('did is not valid for chain Id and nft address');\n    }\n    const schemaFilePath = this.getSchema(ddoCopy.version);\n    const shapes = await rdf.dataset().import(rdf.fromFile(schemaFilePath));\n    const dataStream = Readable.from(JSON.stringify(ddoCopy));\n    const output = formats.parsers.import('application/ld+json', dataStream);\n    if (!output) {\n      extraErrors.output = ['Output is null or invalid'];\n      return [false, extraErrors];\n    }\n    const data = await rdf.dataset().import(output);\n    const validator = new SHACLValidator(shapes, { factory: rdf });\n    const report = await validator.validate(data);\n    if (report.conforms) {\n      return [true, {}];\n    }\n    for (const result of report.results) {\n      const key = result.path?.value.replace('http://schema.org/', '');\n      if (key) {\n        if (!(key in extraErrors)) extraErrors[key] = [];\n        extraErrors[key].push(fromRdf(result.message[0]));\n      }\n    }\n    extraErrors.fullReport = await report.dataset.serialize({\n      format: 'application/ld+json'\n    });\n    return [false, extraErrors];\n  }\n}\n\nexport async function validateDDO(\n  ddoData: Record<string, unknown>\n): Promise<[boolean, Record<string, string[]>]> {\n  try {\n    const ddoInstance = DDOManager.getDDOClass(ddoData);\n    return await ddoInstance.validate();\n  } catch (error) {\n    return [false, { general: [`Validation failed: ${error}`] }];\n  }\n}\n","export enum State {\n  Active = 0,\n  EndOfLife = 1,\n  Deprecated = 2,\n  RevokedByPublisher = 3,\n  OrderingIsTemporaryDisabled = 4,\n  AssetUnlisted = 5\n}\n"],"names":["rdf","SHACLValidator","formats","CREDENTIALS_TYPES","getRdfjsLibraries","_temp6","_temp4","_temp2","_temp","Promise","resolve","import","then","shaclModule","_temp3","envNode","_temp5","formatsModule","e","reject","validateDDO","ddoData","ddoInstance","DDOManager","getDDOClass","validate","_catch","error","general","ALLOWED_VERSIONS","this","_proto","prototype","getDDOData","deleteIndexedMetadataIfExists","ddo","ddoCopy","structuredClone","indexedMetadata","getDid","id","getSchema","version","includes","Error","currentModulePath","fileURLToPath","url","currentDirectory","dirname","schemaPath","existsSync","startsWith","V4DDO","V5DDO","DeprecatedDDO","_DDOManager2","call","_inheritsLoose","_proto2","getDDOFields","data","metadata","services","chainId","credentials","nftAddress","getAssetFields","datatokens","makeDid","createHash","update","ethers","utils","getAddress","digest","updateFields","fields","_fields$indexedMetada","_fields$indexedMetada2","_fields$indexedMetada3","_fields$indexedMetada4","nft","event","purgatory","stats","_this","_ref","updatedDdo","JSON","parse","stringify","extraErrors","push","err","toString","schemaFilePath","dataset","fromFile","shapes","dataStream","Readable","from","output","parsers","validator","factory","report","conforms","_step","_iterator","_createForOfIteratorHelperLoose","results","done","_result$path","result","value","key","path","replace","fromRdf","message","serialize","format","_report$dataset$seria","fullReport","_DDOManager3","_proto3","_data$credentialSubje","_data$credentialSubje2","_data$credentialSubje3","_data$credentialSubje4","_data$credentialSubje5","credentialSubject","_this$getDDOData","_this$getDDOData$cred","getProof","proof","getIssuer","issuer","_fields$indexedMetada5","_fields$indexedMetada6","_fields$indexedMetada7","_fields$indexedMetada8","_this2","_ref2","_ddoCopy$credentialSu","_iterator2","_step2","_result$path2","_report$dataset$seria2","_DDOManager4","_proto4","state","address","name","symbol","owner","created","tokenURI","_fields$indexedMetada9","_this3","_ref3","_step3","_iterator3","_result$path3","_report$dataset$seria3","State","KNOWN_CREDENTIALS_TYPES","ADDRESS","ACCESS_LIST"],"mappings":"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"}