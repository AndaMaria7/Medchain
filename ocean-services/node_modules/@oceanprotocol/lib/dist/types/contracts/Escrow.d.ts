import { Signer } from 'ethers';
import { AbiItem, ReceiptOrEstimate, ValidationResponse } from '../@types';
import { Config } from '../config';
import { SmartContractWithAddress } from './SmartContractWithAddress';
export declare class EscrowContract extends SmartContractWithAddress {
    abiEnterprise: AbiItem[];
    getDefaultAbi(): AbiItem[];
    /**
     * Instantiate AccessList class
     * @param {string} address The contract address.
     * @param {Signer} signer The signer object.
     * @param {string | number} [network] Network id or name
     * @param {Config} [config] The configuration object.
     * @param {AbiItem[]} [abi] ABI array of the smart contract
     * @param {AbiItem[]} abiEnterprise Enterprise ABI array of the smart contract
     */
    constructor(address: string, signer: Signer, network?: string | number, config?: Config, abi?: AbiItem[]);
    /**
     * Get Funds
     * @return {Promise<any>} Funds
     */
    getFunds(token: string): Promise<any>;
    /**
     * Get User Funds
     * @return {Promise<any>} User funds
     */
    getUserFunds(payer: string, token: string): Promise<any>;
    /**
     * Get Locks
     * @return {Promise<[]>} Locks
     */
    getLocks(token: string, payer: string, payee: string): Promise<any[]>;
    /**
     * Get Authorizations
     * @return {Promise<[]>} Authorizations
     */
    getAuthorizations(token: string, payer: string, payee: string): Promise<any[]>;
    /**
     * Checks funds for escrow payment.
     * Does authorization when needed.
     * Does deposit when needed.
     * @param {String} token as payment token for escrow
     * @param {String} consumerAddress as consumerAddress for that environment
     * @param {String} amountToDeposit wanted amount for escrow lock deposit. If this is
     * not provided and funds for escrow are 0 -> fallback to maxLockedAmount, else
     * use balance of payment token.
     * @param {String} maxLockedAmount amount necessary to be paid for starting compute job,
     * returned from initialize compute payment and used for authorize if needed.
     * @param {String} maxLockSeconds max seconds to lock the payment,
     * returned from initialize compute payment and used for authorize if needed.
     * @param {String} maxLockCounts max lock counts,
     * returned from initialize compute payment and used for authorize if needed.
     * @return {Promise<ValidationResponse>} validation response
     */
    verifyFundsForEscrowPayment(token: string, consumerAddress: string, amountToDeposit?: string, maxLockedAmount?: string, maxLockSeconds?: string, maxLockCounts?: string): Promise<ValidationResponse>;
    /**
     * Deposit funds
     * @param {String} token Token address
     * @param {String} amount amount
     * @param {Boolean} estimateGas if True, return gas estimate
     * @return {Promise<ReceiptOrEstimate>} returns the transaction receipt or the estimateGas value
     */
    deposit<G extends boolean = false>(token: string, amount: string, estimateGas?: G): Promise<ReceiptOrEstimate<G>>;
    /**
     * Withdraw funds
     * @param {String[]} tokens Array of token addresses
     * @param {String[]} amounts Array of token amounts
     * @param {Boolean} estimateGas if True, return gas estimate
     * @return {Promise<ReceiptOrEstimate>} returns the transaction receipt or the estimateGas value
     */
    withdraw<G extends boolean = false>(tokens: string[], amounts: string[], estimateGas?: G): Promise<ReceiptOrEstimate<G>>;
    /**
     * Authorize locks
     * @param {String} token Token address
     * @param {String} payee,
     * @param {String} maxLockedAmount,
     * @param {String} maxLockSeconds,
     * @param {String} maxLockCounts,
     * @param {Boolean} estimateGas if True, return gas estimate
     * @return {Promise<ReceiptOrEstimate>} returns the transaction receipt or the estimateGas value
     */
    authorize<G extends boolean = false>(token: string, payee: string, maxLockedAmount: string, maxLockSeconds: string, maxLockCounts: string, estimateGas?: G): Promise<ReceiptOrEstimate<G>>;
    /**
     * Cancel expired locks
     * @param {String} jobId Job ID with hash
     * @param {String} token Token address
     * @param {String} payee, Payee address for the compute job,
     * @param {String} payer, Payer address for the compute job
     * @param {Boolean} estimateGas if True, return gas estimate
     * @return {Promise<ReceiptOrEstimate>} returns the transaction receipt or the estimateGas value
     */
    cancelExpiredLocks<G extends boolean = false>(jobIds: string[], tokens: string[], payers: string[], payees: string[], estimateGas?: G): Promise<ReceiptOrEstimate<G>>;
}
