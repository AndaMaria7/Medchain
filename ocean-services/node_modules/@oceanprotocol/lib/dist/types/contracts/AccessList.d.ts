import { Signer } from 'ethers';
import { AbiItem, ReceiptOrEstimate } from '../@types/index.js';
import { Config } from '../config/index.js';
import { SmartContractWithAddress } from './SmartContractWithAddress.js';
export declare class AccessListContract extends SmartContractWithAddress {
    abiEnterprise: AbiItem[];
    getDefaultAbi(): AbiItem[];
    /**
     * Instantiate AccessList class
     * @param {string} address The contract address.
     * @param {Signer} signer The signer object.
     * @param {string | number} [network] Network id or name
     * @param {Config} [config] The configuration object.
     * @param {AbiItem[]} [abi] ABI array of the smart contract
     * @param {AbiItem[]} abiEnterprise Enterprise ABI array of the smart contract
     */
    constructor(address: string, signer: Signer, network?: string | number, config?: Config, abi?: AbiItem[]);
    /**
     * Get Token Uri
     * @return {Promise<string>} Token URI
     */
    getTokenUri(tokenId: number): Promise<string>;
    /**
     * Get Owner
     * @return {Promise<string>} Owner
     */
    getOwner(): Promise<string>;
    /**
     * Get Id
     * @return {Promise<string>} Id
     */
    getId(): Promise<number>;
    /**
     * Get Name of Access list
     * @return {Promise<string>} Name
     */
    getName(): Promise<string>;
    /**
     * Get Symbol of Access list
     * @return {Promise<string>} Symbol
     */
    getSymbol(): Promise<string>;
    /**
     * Get Address Balance for access list token
     * @param {String} address user adress
     * @return {Promise<String>} balance  Number of datatokens. Will be converted from wei
     */
    balance(address: string): Promise<string>;
    /**
     * Add address to access list
     * @param {String} user Minter address
     * @param {String} tokenUri tokenURI
     * @param {Boolean} estimateGas if True, return gas estimate
     * @return {Promise<ReceiptOrEstimate>} returns the transaction receipt or the estimateGas value
     */
    mint<G extends boolean = false>(user: string, tokenUri: string, estimateGas?: G): Promise<ReceiptOrEstimate<G>>;
    /**
     * Batch add addresses to the access list
     * @param {String} users Minter addresses
     * @param {String} tokenUris tokenURI
     * @param {Boolean} estimateGas if True, return gas estimate
     * @return {Promise<ReceiptOrEstimate>} returns the transaction receipt or the estimateGas value
     */
    batchMint<G extends boolean = false>(users: Array<string>, tokenUris: Array<string>, estimateGas?: G): Promise<ReceiptOrEstimate<G>>;
    /**
     * Delete address from access list
     * @param {Number} tokenId token ID
     * @param {Boolean} estimateGas if True, return gas estimate
     * @return {Promise<ReceiptOrEstimate>} returns the transaction receipt or the estimateGas value
     */
    burn<G extends boolean = false>(tokenId: number, estimateGas?: G): Promise<ReceiptOrEstimate<G>>;
    /**
     * Transfer Ownership of an access list, called by owner of access list
     * @param {Number} newOwner new owner of the access list
     * @param {Boolean} estimateGas if True, return gas estimate
     * @return {Promise<ReceiptOrEstimate>} returns the transaction receipt or the estimateGas value
     */
    transferOwnership<G extends boolean = false>(newOwner: string, estimateGas?: G): Promise<ReceiptOrEstimate<G>>;
    /**
     * Renounce Ownership of an access list, called by owner of access list
     * @param {Boolean} estimateGas if True, return gas estimate
     * @return {Promise<ReceiptOrEstimate>} returns the transaction receipt or the estimateGas value
     */
    renounceOwnership<G extends boolean = false>(estimateGas?: G): Promise<ReceiptOrEstimate<G>>;
}
